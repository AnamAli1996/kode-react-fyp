/**
 * Delete file.
 * @function filedel
 * @param {string} filename - Filename to delete.
 * @param {object} [options] - Optional settings.
 * @param {boolean} [options.force=false] - Unlink even if readonly.
 * @returns {Promise}
 */

'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rimraf = require('rimraf');

var _require = require('asfs'),
    existsAsync = _require.existsAsync;

var argx = require('argx');
var aglob = require('aglob');
var doUnlink = require('./filing/do_unlink');
var isDir = require('./filing/is_dir');

/** @lends filedel */
async function filedel(patterns) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var args = argx(arguments);
  if (args.pop('function')) {
    throw new Error('[filedel] Callback is no more supported. Use promise interface instead.');
  }
  var _options = options,
      _options$cwd = _options.cwd,
      cwd = _options$cwd === undefined ? process.cwd() : _options$cwd;

  options = args.pop('object') || {};

  var filenames = await aglob(patterns, { cwd: cwd });
  var result = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(filenames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var filename = _step.value;

      var exists = await existsAsync(filename);
      if (!exists) {
        return;
      }
      var isDir_ = await isDir(filename);
      if (isDir_) {
        throw new Error('[filedel] Can not unlink directory: ' + filename);
      }
      await doUnlink(filename, Boolean(options.force));
      result.push(filename);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

(0, _assign2.default)(filedel, {
  recursive: async function recursive(dirname) {
    var exists = await existsAsync(dirname);
    if (!exists) {
      return;
    }
    var isDir_ = await isDir(dirname);
    if (!isDir_) {
      throw new Error('[filedel] Not a directory: ' + dirname);
    }
    await new _promise2.default(function (resolve, reject) {
      return rimraf(dirname, function (err) {
        return err ? reject(err) : resolve();
      });
    });
  }
});

module.exports = filedel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGVkZWwuanMiXSwibmFtZXMiOlsicmltcmFmIiwicmVxdWlyZSIsImV4aXN0c0FzeW5jIiwiYXJneCIsImFnbG9iIiwiZG9VbmxpbmsiLCJpc0RpciIsImZpbGVkZWwiLCJwYXR0ZXJucyIsIm9wdGlvbnMiLCJhcmdzIiwiYXJndW1lbnRzIiwicG9wIiwiRXJyb3IiLCJjd2QiLCJwcm9jZXNzIiwiZmlsZW5hbWVzIiwicmVzdWx0IiwiZmlsZW5hbWUiLCJleGlzdHMiLCJpc0Rpcl8iLCJCb29sZWFuIiwiZm9yY2UiLCJwdXNoIiwicmVjdXJzaXZlIiwiZGlybmFtZSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxTQUFTQyxRQUFRLFFBQVIsQ0FBZjs7ZUFDc0JBLFFBQVEsTUFBUixDO0lBQWZDLFcsWUFBQUEsVzs7QUFDUCxJQUFNQyxPQUFPRixRQUFRLE1BQVIsQ0FBYjtBQUNBLElBQU1HLFFBQVFILFFBQVEsT0FBUixDQUFkO0FBQ0EsSUFBTUksV0FBV0osUUFBUSxvQkFBUixDQUFqQjtBQUNBLElBQU1LLFFBQVFMLFFBQVEsaUJBQVIsQ0FBZDs7QUFFQTtBQUNBLGVBQWVNLE9BQWYsQ0FBd0JDLFFBQXhCLEVBQWdEO0FBQUEsTUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUM5QyxNQUFNQyxPQUFPUCxLQUFLUSxTQUFMLENBQWI7QUFDQSxNQUFJRCxLQUFLRSxHQUFMLENBQVMsVUFBVCxDQUFKLEVBQTBCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLHlFQUFWLENBQU47QUFDRDtBQUo2QyxpQkFLaEJKLE9BTGdCO0FBQUEsOEJBS3ZDSyxHQUx1QztBQUFBLE1BS3ZDQSxHQUx1QyxnQ0FLakNDLFFBQVFELEdBQVIsRUFMaUM7O0FBTTlDTCxZQUFVQyxLQUFLRSxHQUFMLENBQVMsUUFBVCxLQUFzQixFQUFoQzs7QUFFQSxNQUFNSSxZQUFZLE1BQU1aLE1BQU1JLFFBQU4sRUFBZ0IsRUFBQ00sUUFBRCxFQUFoQixDQUF4QjtBQUNBLE1BQU1HLFNBQVMsRUFBZjtBQVQ4QztBQUFBO0FBQUE7O0FBQUE7QUFVOUMsb0RBQXVCRCxTQUF2Qiw0R0FBa0M7QUFBQSxVQUF2QkUsUUFBdUI7O0FBQ2hDLFVBQU1DLFNBQVMsTUFBTWpCLFlBQVlnQixRQUFaLENBQXJCO0FBQ0EsVUFBSSxDQUFDQyxNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0QsVUFBTUMsU0FBUyxNQUFNZCxNQUFNWSxRQUFOLENBQXJCO0FBQ0EsVUFBSUUsTUFBSixFQUFZO0FBQ1YsY0FBTSxJQUFJUCxLQUFKLDBDQUFpREssUUFBakQsQ0FBTjtBQUNEO0FBQ0QsWUFBTWIsU0FBU2EsUUFBVCxFQUFtQkcsUUFBUVosUUFBUWEsS0FBaEIsQ0FBbkIsQ0FBTjtBQUNBTCxhQUFPTSxJQUFQLENBQVlMLFFBQVo7QUFDRDtBQXJCNkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFzQjlDLFNBQU9ELE1BQVA7QUFDRDs7QUFFRCxzQkFBY1YsT0FBZCxFQUF1QjtBQUNmaUIsV0FEZSwyQkFDSkMsT0FESSxFQUNLO0FBQ3hCLFFBQU1OLFNBQVMsTUFBTWpCLFlBQVl1QixPQUFaLENBQXJCO0FBQ0EsUUFBSSxDQUFDTixNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0QsUUFBTUMsU0FBUyxNQUFNZCxNQUFNbUIsT0FBTixDQUFyQjtBQUNBLFFBQUksQ0FBQ0wsTUFBTCxFQUFhO0FBQ1gsWUFBTSxJQUFJUCxLQUFKLGlDQUF3Q1ksT0FBeEMsQ0FBTjtBQUNEO0FBQ0QsVUFBTSxzQkFBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVY7QUFBQSxhQUNoQjNCLE9BQU95QixPQUFQLEVBQWdCLFVBQUNHLEdBQUQ7QUFBQSxlQUFTQSxNQUFNRCxPQUFPQyxHQUFQLENBQU4sR0FBb0JGLFNBQTdCO0FBQUEsT0FBaEIsQ0FEZ0I7QUFBQSxLQUFaLENBQU47QUFHRDtBQWJvQixDQUF2Qjs7QUFnQkFHLE9BQU9DLE9BQVAsR0FBaUJ2QixPQUFqQiIsImZpbGUiOiJmaWxlZGVsLmpzIiwic291cmNlUm9vdCI6ImxpYiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVsZXRlIGZpbGUuXG4gKiBAZnVuY3Rpb24gZmlsZWRlbFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWUgdG8gZGVsZXRlLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZT1mYWxzZV0gLSBVbmxpbmsgZXZlbiBpZiByZWFkb25seS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCdyaW1yYWYnKVxuY29uc3Qge2V4aXN0c0FzeW5jfSA9IHJlcXVpcmUoJ2FzZnMnKVxuY29uc3QgYXJneCA9IHJlcXVpcmUoJ2FyZ3gnKVxuY29uc3QgYWdsb2IgPSByZXF1aXJlKCdhZ2xvYicpXG5jb25zdCBkb1VubGluayA9IHJlcXVpcmUoJy4vZmlsaW5nL2RvX3VubGluaycpXG5jb25zdCBpc0RpciA9IHJlcXVpcmUoJy4vZmlsaW5nL2lzX2RpcicpXG5cbi8qKiBAbGVuZHMgZmlsZWRlbCAqL1xuYXN5bmMgZnVuY3Rpb24gZmlsZWRlbCAocGF0dGVybnMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBhcmdzID0gYXJneChhcmd1bWVudHMpXG4gIGlmIChhcmdzLnBvcCgnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2ZpbGVkZWxdIENhbGxiYWNrIGlzIG5vIG1vcmUgc3VwcG9ydGVkLiBVc2UgcHJvbWlzZSBpbnRlcmZhY2UgaW5zdGVhZC4nKVxuICB9XG4gIGNvbnN0IHtjd2QgPSBwcm9jZXNzLmN3ZCgpfSA9IG9wdGlvbnNcbiAgb3B0aW9ucyA9IGFyZ3MucG9wKCdvYmplY3QnKSB8fCB7fVxuXG4gIGNvbnN0IGZpbGVuYW1lcyA9IGF3YWl0IGFnbG9iKHBhdHRlcm5zLCB7Y3dkfSlcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBmaWxlbmFtZXMpIHtcbiAgICBjb25zdCBleGlzdHMgPSBhd2FpdCBleGlzdHNBc3luYyhmaWxlbmFtZSlcbiAgICBpZiAoIWV4aXN0cykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGlzRGlyXyA9IGF3YWl0IGlzRGlyKGZpbGVuYW1lKVxuICAgIGlmIChpc0Rpcl8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW2ZpbGVkZWxdIENhbiBub3QgdW5saW5rIGRpcmVjdG9yeTogJHtmaWxlbmFtZX1gKVxuICAgIH1cbiAgICBhd2FpdCBkb1VubGluayhmaWxlbmFtZSwgQm9vbGVhbihvcHRpb25zLmZvcmNlKSlcbiAgICByZXN1bHQucHVzaChmaWxlbmFtZSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbk9iamVjdC5hc3NpZ24oZmlsZWRlbCwge1xuICBhc3luYyByZWN1cnNpdmUgKGRpcm5hbWUpIHtcbiAgICBjb25zdCBleGlzdHMgPSBhd2FpdCBleGlzdHNBc3luYyhkaXJuYW1lKVxuICAgIGlmICghZXhpc3RzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgaXNEaXJfID0gYXdhaXQgaXNEaXIoZGlybmFtZSlcbiAgICBpZiAoIWlzRGlyXykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZmlsZWRlbF0gTm90IGEgZGlyZWN0b3J5OiAke2Rpcm5hbWV9YClcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIHJpbXJhZihkaXJuYW1lLCAoZXJyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSlcbiAgICApXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZmlsZWRlbFxuIl19