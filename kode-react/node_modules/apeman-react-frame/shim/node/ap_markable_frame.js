/**
 * iframe components with marker.
 * @class ApMarkableFrame
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _asobj = require('asobj');

var _apemanReactMixinLayout = require('apeman-react-mixin-layout');

var _ap_frame = require('./ap_frame');

var _ap_frame2 = _interopRequireDefault(_ap_frame);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var markerKey = function markerKey(selector, i) {
  return [selector, i].join('-');
};

/** @lends ApMarkableFrame */
var ApMarkableFrame = _react2.default.createClass({
  displayName: 'ApMarkableFrame',


  // --------------------
  // Specs
  // --------------------

  propTypes: {
    /** Selector for detectable elements */
    detectableSelector: _react.PropTypes.string,
    /** Handler for detection */
    onDetect: _react.PropTypes.func,
    /** Selector for highlight */
    highlightSelector: _react.PropTypes.string,
    /** Handler for tap on markable */
    onMarkableTap: _react.PropTypes.func,
    /** Handler for hover-in on markable */
    onMarkableHoverIn: _react.PropTypes.func,
    /** Handler for hover-out on markable */
    onMarkableHoverOut: _react.PropTypes.func
  },

  mixins: [_apemanReactMixinLayout.ApLayoutMixin],

  statics: {},

  getInitialState: function getInitialState() {
    var s = this;
    var props = s.props;

    return {
      detected: null,
      highlighted: null
    };
  },
  getDefaultProps: function getDefaultProps() {
    return {};
  },
  render: function render() {
    var s = this;
    var state = s.state;
    var props = s.props;
    var detected = state.detected;

    var className = (0, _classnames2.default)('ap-frame', 'ap-markable-frame', props.className);
    return _react2.default.createElement(
      _ap_frame2.default,
      _extends({}, props, {
        className: className,
        onLoad: s.handleLoad }),
      Object.keys(detected || {}).map(function (selector) {
        return s._renderMarkable(selector, detected[selector] || []);
      })
    );
  },


  // --------------------
  // Lifecycle
  // --------------------

  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    var s = this;
    var props = s.props;
    var state = s.state;

    return !(0, _asobj.shallowEqual)(props, nextProps) || !(0, _asobj.shallowEqual)(state, nextState);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var s = this;
    var props = s.props;


    var highlightChanged = props.highlightSelector !== nextProps.highlightSelector;
    if (highlightChanged) {
      var highlighted = s.queryMarkables(props.highlightSelector);
      s.setState({ highlighted: highlighted });
      s.layout();
    }
  },


  // ------------------
  // Custom
  // ------------------

  handleLoad: function handleLoad(e) {
    var s = this;
    var props = s.props;

    s.iframe = e.target;

    if (props.onLoad) {
      props.onLoad(e);
    }

    var markables = s.queryMarkables(props.detectableSelector);
    s.setState({ detected: markables });
    if (props.onDetect) {
      props.onDetect({ markables: markables });
    }
  },
  getContentBody: function getContentBody() {
    var s = this;
    var iframe = s.iframe;

    if (!iframe) {
      return null;
    }
    var contentDocument = iframe.contentDocument || iframe.contentWindow && iframe.contentWindow.document;
    if (!contentDocument) {
      return null;
    }
    return contentDocument.body;
  },
  queryMarkables: function queryMarkables(selector) {
    var s = this;
    var body = s.getContentBody();
    if (!body) {
      return null;
    }
    if (!selector) {
      return null;
    }
    return (selector || '').split(',').map(function (selector) {
      return selector.trim();
    }).reduce(function (items, selector) {
      return Object.assign(items, _defineProperty({}, selector, [].concat(_toConsumableArray(body.querySelectorAll(selector)))));
    }, {});
  },


  // ------------------
  // For ApLayoutMixin
  // ------------------
  getInitialLayouts: function getInitialLayouts() {
    return {
      markables: {}
    };
  },
  calcLayouts: function calcLayouts() {
    var s = this;
    var props = s.props;
    var state = s.state;

    var markables = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(state.detected || {})[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var selector = _step.value;

        var elms = state.detected[selector];
        for (var i = 0; i < elms.length; i++) {
          var elm = elms[i];
          var key = markerKey(selector, i);

          var _elm$getBoundingClien = elm.getBoundingClientRect();

          var top = _elm$getBoundingClien.top;
          var left = _elm$getBoundingClien.left;
          var width = _elm$getBoundingClien.width;
          var height = _elm$getBoundingClien.height;

          markables[key] = { top: top, left: left, width: width, height: height };
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return {
      markables: markables
    };
  },


  // ------------------
  // Private
  // ------------------

  _renderMarkable: function _renderMarkable(selector, elms) {
    var s = this;
    var layouts = s.layouts;

    return _react2.default.createElement(
      'div',
      { className: 'ap-markable-frame-markable',
        'data-ap-markable-slector': selector,
        key: selector },
      elms.map(function (elm, i) {
        var key = markerKey(selector, i);
        var style = layouts.markables[key];
        return _react2.default.createElement('div', { className: 'ap-markable-frame-markable-item',
          'data-ap-markable-key': key,
          key: key,
          style: style
        });
      })
    );
  }
});

exports.default = ApMarkableFrame;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwX21hcmthYmxlX2ZyYW1lLmpzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQTs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFJLFlBQVksU0FBWixTQUFZLENBQUMsUUFBRCxFQUFXLENBQVg7QUFBQSxTQUFpQixDQUFFLFFBQUYsRUFBWSxDQUFaLEVBQWdCLElBQWhCLENBQXFCLEdBQXJCLENBQWpCO0FBQUEsQ0FBaEI7O0FBRUE7QUFDQSxJQUFNLGtCQUFrQixnQkFBTSxXQUFOLENBQWtCO0FBQUE7OztBQUV4QztBQUNBO0FBQ0E7O0FBRUEsYUFBVztBQUNUO0FBQ0Esd0JBQW9CLGlCQUFNLE1BRmpCO0FBR1Q7QUFDQSxjQUFVLGlCQUFNLElBSlA7QUFLVDtBQUNBLHVCQUFtQixpQkFBTSxNQU5oQjtBQU9UO0FBQ0EsbUJBQWUsaUJBQU0sSUFSWjtBQVNUO0FBQ0EsdUJBQW1CLGlCQUFNLElBVmhCO0FBV1Q7QUFDQSx3QkFBb0IsaUJBQU07QUFaakIsR0FONkI7O0FBcUJ4QyxVQUFRLHVDQXJCZ0M7O0FBeUJ4QyxXQUFTLEVBekIrQjs7QUEyQnhDLGlCQTNCd0MsNkJBMkJyQjtBQUNqQixRQUFNLElBQUksSUFBVjtBQURpQixRQUVYLEtBRlcsR0FFRCxDQUZDLENBRVgsS0FGVzs7QUFHakIsV0FBTztBQUNMLGdCQUFVLElBREw7QUFFTCxtQkFBYTtBQUZSLEtBQVA7QUFJRCxHQWxDdUM7QUFvQ3hDLGlCQXBDd0MsNkJBb0NyQjtBQUNqQixXQUFPLEVBQVA7QUFDRCxHQXRDdUM7QUF3Q3hDLFFBeEN3QyxvQkF3QzlCO0FBQ1IsUUFBTSxJQUFJLElBQVY7QUFEUSxRQUVGLEtBRkUsR0FFZSxDQUZmLENBRUYsS0FGRTtBQUFBLFFBRUssS0FGTCxHQUVlLENBRmYsQ0FFSyxLQUZMO0FBQUEsUUFHRixRQUhFLEdBR1csS0FIWCxDQUdGLFFBSEU7O0FBSVIsUUFBSSxZQUFZLDBC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QUE7QUFBQTtBQUFBOztBQWFiLFdBQU87QUFDTDtBQURLLEtBQVA7QUFHRCxHQTFKdUM7OztBQTRKeEM7QUFDQTtBQUNBOztBQUVBLGlCQWhLd0MsMkJBZ0t2QixRQWhLdUIsRUFnS2IsSUFoS2EsRUFnS1A7QUFDL0IsUUFBTSxJQUFJLElBQVY7QUFEK0IsUUFFekIsT0FGeUIsR0FFYixDQUZhLENBRXpCLE9BRnlCOztBQUcvQixXQUNFO0FBQUE7QUFBQSxRQUFLLFdBQVUsNEJBQWY7QUFDSyxvQ0FBMkIsUUFEaEM7QUFFSyxhQUFNLFFBRlg7QUFJSSxXQUFLLEdBQUwsQ0FBUyxVQUFDLEdBQUQsRUFBTSxDQUFOLEVBQVk7QUFDbkIsWUFBSSxNQUFNLFVBQVUsUUFBVixFQUFvQixDQUFwQixDQUFWO0FBQ0EsWUFBSSxRQUFRLFFBQVEsU0FBUixDQUFtQixHQUFuQixDQUFaO0FBQ0EsZUFDRSx1Q0FBSyxXQUFVLGlDQUFmO0FBQ0ssa0NBQXVCLEdBRDVCO0FBRUssZUFBTSxHQUZYO0FBR0ssaUJBQVE7QUFIYixVQURGO0FBUUQsT0FYRDtBQUpKLEtBREY7QUFvQkQ7QUF2THVDLENBQWxCLENBQXhCOztrQkEwTGUsZSIsImZpbGUiOiJhcF9tYXJrYWJsZV9mcmFtZS5qc3giLCJzb3VyY2VSb290IjoibGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBpZnJhbWUgY29tcG9uZW50cyB3aXRoIG1hcmtlci5cbiAqIEBjbGFzcyBBcE1hcmthYmxlRnJhbWVcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IFJlYWN0LCB7UHJvcFR5cGVzIGFzIHR5cGVzfSBmcm9tICdyZWFjdCdcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnXG5pbXBvcnQge3NoYWxsb3dFcXVhbH0gZnJvbSAnYXNvYmonXG5pbXBvcnQge0FwTGF5b3V0TWl4aW59IGZyb20gJ2FwZW1hbi1yZWFjdC1taXhpbi1sYXlvdXQnXG5pbXBvcnQgQXBGcmFtZSBmcm9tICcuL2FwX2ZyYW1lJ1xuXG5sZXQgbWFya2VyS2V5ID0gKHNlbGVjdG9yLCBpKSA9PiBbIHNlbGVjdG9yLCBpIF0uam9pbignLScpXG5cbi8qKiBAbGVuZHMgQXBNYXJrYWJsZUZyYW1lICovXG5jb25zdCBBcE1hcmthYmxlRnJhbWUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3BlY3NcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcm9wVHlwZXM6IHtcbiAgICAvKiogU2VsZWN0b3IgZm9yIGRldGVjdGFibGUgZWxlbWVudHMgKi9cbiAgICBkZXRlY3RhYmxlU2VsZWN0b3I6IHR5cGVzLnN0cmluZyxcbiAgICAvKiogSGFuZGxlciBmb3IgZGV0ZWN0aW9uICovXG4gICAgb25EZXRlY3Q6IHR5cGVzLmZ1bmMsXG4gICAgLyoqIFNlbGVjdG9yIGZvciBoaWdobGlnaHQgKi9cbiAgICBoaWdobGlnaHRTZWxlY3RvcjogdHlwZXMuc3RyaW5nLFxuICAgIC8qKiBIYW5kbGVyIGZvciB0YXAgb24gbWFya2FibGUgKi9cbiAgICBvbk1hcmthYmxlVGFwOiB0eXBlcy5mdW5jLFxuICAgIC8qKiBIYW5kbGVyIGZvciBob3Zlci1pbiBvbiBtYXJrYWJsZSAqL1xuICAgIG9uTWFya2FibGVIb3ZlckluOiB0eXBlcy5mdW5jLFxuICAgIC8qKiBIYW5kbGVyIGZvciBob3Zlci1vdXQgb24gbWFya2FibGUgKi9cbiAgICBvbk1hcmthYmxlSG92ZXJPdXQ6IHR5cGVzLmZ1bmNcbiAgfSxcblxuICBtaXhpbnM6IFtcbiAgICBBcExheW91dE1peGluXG4gIF0sXG5cbiAgc3RhdGljczoge30sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlICgpIHtcbiAgICBjb25zdCBzID0gdGhpc1xuICAgIGxldCB7IHByb3BzIH0gPSBzXG4gICAgcmV0dXJuIHtcbiAgICAgIGRldGVjdGVkOiBudWxsLFxuICAgICAgaGlnaGxpZ2h0ZWQ6IG51bGxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzICgpIHtcbiAgICByZXR1cm4ge31cbiAgfSxcblxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgbGV0IHsgc3RhdGUsIHByb3BzIH0gPSBzXG4gICAgbGV0IHsgZGV0ZWN0ZWQgfSA9IHN0YXRlXG4gICAgbGV0IGNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoJ2FwLWZyYW1lJywgJ2FwLW1hcmthYmxlLWZyYW1lJywgcHJvcHMuY2xhc3NOYW1lKVxuICAgIHJldHVybiAoXG4gICAgICA8QXBGcmFtZSB7IC4uLnByb3BzIH1cbiAgICAgICAgY2xhc3NOYW1lPXsgY2xhc3NOYW1lIH1cbiAgICAgICAgb25Mb2FkPXsgcy5oYW5kbGVMb2FkIH0+XG4gICAgICAgIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkZXRlY3RlZCB8fCB7fSkubWFwKChzZWxlY3RvcikgPT5cbiAgICAgICAgICAgIHMuX3JlbmRlck1hcmthYmxlKHNlbGVjdG9yLCBkZXRlY3RlZFsgc2VsZWN0b3IgXSB8fCBbXSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIDwvQXBGcmFtZT5cbiAgICApXG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTGlmZWN5Y2xlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSBzXG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwocHJvcHMsIG5leHRQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChzdGF0ZSwgbmV4dFN0YXRlKVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgbGV0IHsgcHJvcHMgfSA9IHNcblxuICAgIGxldCBoaWdobGlnaHRDaGFuZ2VkID0gcHJvcHMuaGlnaGxpZ2h0U2VsZWN0b3IgIT09IG5leHRQcm9wcy5oaWdobGlnaHRTZWxlY3RvclxuICAgIGlmIChoaWdobGlnaHRDaGFuZ2VkKSB7XG4gICAgICBsZXQgaGlnaGxpZ2h0ZWQgPSBzLnF1ZXJ5TWFya2FibGVzKHByb3BzLmhpZ2hsaWdodFNlbGVjdG9yKVxuICAgICAgcy5zZXRTdGF0ZSh7IGhpZ2hsaWdodGVkIH0pXG4gICAgICBzLmxheW91dCgpXG4gICAgfVxuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBDdXN0b21cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgaGFuZGxlTG9hZCAoZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgbGV0IHsgcHJvcHMgfSA9IHNcbiAgICBzLmlmcmFtZSA9IGUudGFyZ2V0XG5cbiAgICBpZiAocHJvcHMub25Mb2FkKSB7XG4gICAgICBwcm9wcy5vbkxvYWQoZSlcbiAgICB9XG5cbiAgICBsZXQgbWFya2FibGVzID0gcy5xdWVyeU1hcmthYmxlcyhwcm9wcy5kZXRlY3RhYmxlU2VsZWN0b3IpXG4gICAgcy5zZXRTdGF0ZSh7IGRldGVjdGVkOiBtYXJrYWJsZXMgfSlcbiAgICBpZiAocHJvcHMub25EZXRlY3QpIHtcbiAgICAgIHByb3BzLm9uRGV0ZWN0KHsgbWFya2FibGVzIH0pXG4gICAgfVxuICB9LFxuXG4gIGdldENvbnRlbnRCb2R5ICgpIHtcbiAgICBjb25zdCBzID0gdGhpc1xuICAgIGxldCB7IGlmcmFtZSB9ID0gc1xuICAgIGlmICghaWZyYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBsZXQgY29udGVudERvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCAoaWZyYW1lLmNvbnRlbnRXaW5kb3cgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpXG4gICAgaWYgKCFjb250ZW50RG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBjb250ZW50RG9jdW1lbnQuYm9keVxuICB9LFxuXG4gIHF1ZXJ5TWFya2FibGVzIChzZWxlY3Rvcikge1xuICAgIGNvbnN0IHMgPSB0aGlzXG4gICAgbGV0IGJvZHkgPSBzLmdldENvbnRlbnRCb2R5KClcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiAoc2VsZWN0b3IgfHwgJycpLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci50cmltKCkpXG4gICAgICAucmVkdWNlKChpdGVtcywgc2VsZWN0b3IpID0+IE9iamVjdC5hc3NpZ24oaXRlbXMsIHtcbiAgICAgICAgW3NlbGVjdG9yXTogWyAuLi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIF1cbiAgICAgIH0pLCB7fSlcbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRm9yIEFwTGF5b3V0TWl4aW5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGdldEluaXRpYWxMYXlvdXRzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2FibGVzOiB7fVxuICAgIH1cbiAgfSxcblxuICBjYWxjTGF5b3V0cyAoKSB7XG4gICAgY29uc3QgcyA9IHRoaXNcbiAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9ICBzXG4gICAgbGV0IG1hcmthYmxlcyA9IHt9XG4gICAgZm9yIChsZXQgc2VsZWN0b3Igb2YgT2JqZWN0LmtleXMoc3RhdGUuZGV0ZWN0ZWQgfHwge30pKSB7XG4gICAgICBsZXQgZWxtcyA9IHN0YXRlLmRldGVjdGVkWyBzZWxlY3RvciBdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVsbSA9IGVsbXNbIGkgXVxuICAgICAgICBsZXQga2V5ID0gbWFya2VyS2V5KHNlbGVjdG9yLCBpKVxuICAgICAgICBsZXQgeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBtYXJrYWJsZXNbIGtleSBdID0geyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWFya2FibGVzXG4gICAgfVxuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQcml2YXRlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIF9yZW5kZXJNYXJrYWJsZSAoc2VsZWN0b3IsIGVsbXMpIHtcbiAgICBjb25zdCBzID0gdGhpc1xuICAgIGxldCB7IGxheW91dHMgfSA9IHNcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9J2FwLW1hcmthYmxlLWZyYW1lLW1hcmthYmxlJ1xuICAgICAgICAgICBkYXRhLWFwLW1hcmthYmxlLXNsZWN0b3I9eyBzZWxlY3RvciB9XG4gICAgICAgICAgIGtleT17IHNlbGVjdG9yIH0+XG4gICAgICAgIHtcbiAgICAgICAgICBlbG1zLm1hcCgoZWxtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gbWFya2VyS2V5KHNlbGVjdG9yLCBpKVxuICAgICAgICAgICAgbGV0IHN0eWxlID0gbGF5b3V0cy5tYXJrYWJsZXNbIGtleSBdXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nYXAtbWFya2FibGUtZnJhbWUtbWFya2FibGUtaXRlbSdcbiAgICAgICAgICAgICAgICAgICBkYXRhLWFwLW1hcmthYmxlLWtleT17IGtleSB9XG4gICAgICAgICAgICAgICAgICAga2V5PXsga2V5IH1cbiAgICAgICAgICAgICAgICAgICBzdHlsZT17IHN0eWxlIH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IEFwTWFya2FibGVGcmFtZVxuIl19