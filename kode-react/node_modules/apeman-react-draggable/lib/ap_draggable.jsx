/**
 * apeman react package for draggable component.
 * @augments ApComponent
 * @class ApDraggable
 */

'use strict'

import React, {PropTypes as types} from 'react'
import ReactDOM from 'react-dom'
import classnames from 'classnames'

import numcal from 'numcal'
import rangecal from 'rangecal'
import veccal from 'veccal'
import {ApTouchable} from 'apeman-react-touchable'

const directions = [
  'HORIZONTAL',
  'LEFT',
  'RIGHT',
  'VERTICAL',
  'UP',
  'DOWN',
  'NONE',
  'ALL'
]
const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || (-9007199254740991)
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || (9007199254740991)
const DEFAULT_TRANSITION_DURATION = 80

/** @lends ApDraggable */
const ApDraggable = React.createClass({

  // --------------------
  // Specs
  // --------------------

  propTypes: {
    /** Handler for drag start */
    onStart: types.func,
    /** Handler for drag move */
    onMove: types.func,
    /** Handler for drag stop */
    onStop: types.func,
    shouldMove: types.func,
    /** Move direction */
    direction: types.oneOf(directions),
    x: types.number,
    minX: types.number,
    maxX: types.number,
    y: types.number,
    minY: types.number,
    maxY: types.number
  },

  statics: {
    enums: {
      directions: directions
    },
    movement (cx, cy, base, direction) {
      let [x, y] = veccal.subtract(
        [ cx, cy ],
        [ base.x, base.y ]
      )
      switch (direction) {
        case 'HORIZONTAL':
        case 'LEFT':
        case 'RIGHT':
          y = 0
          break
        case 'VERTICAL':
        case 'UP':
        case 'DOWN':
          x = 0
          break
        case 'NONE':
          x = 0
          y = 0
          break
        default:
          break
      }
      return [ x, y ]
    }
  },

  getInitialState () {
    const s = this
    let { props } = s
    return {
      dragging: false,
      base: {
        x: 0,
        y: 0
      },
      move: {
        x: props.x || 0,
        y: props.y || 0
      }
    }
  },

  getDefaultProps () {
    return {
      direction: 'ALL',
      shouldMove () {
        return true
      },
      minX: MIN_SAFE_INTEGER,
      maxX: MAX_SAFE_INTEGER,
      minY: MIN_SAFE_INTEGER,
      maxY: MAX_SAFE_INTEGER
    }
  },

  render () {
    const s = this
    let { props, state } = s
    let className = classnames('ap-draggable', {
      'ap-draggable-dragging': state.dragging
    }, props.className)
    return (
      <ApTouchable { ...props }
        className={ className }
        onPanStart={ s.handlePanStart }
        onPan={ s.handlePanMove }
        onPanEnd={ s.handlePanEnd }
        panThreshold={ 1 }
        onPanCancel={ s.handlePanCancel }
        panDirection={ props.direction }
      >
        { props.children }
      </ApTouchable>
    )
  },

  // --------------------
  // Lifecycle
  // --------------------

  componentWillReceiveProps (nextProps) {
    const s = this
    let { state } = s
    let { x, y } = nextProps

    let hasX = typeof x !== 'undefined'
    let hasY = typeof y !== 'undefined'
    let changed = hasX || hasY
    if (changed) {
      x = hasX ? x : state.move.x
      y = hasY ? y : state.move.y
      s.setState({
        move: {
          x: x,
          y: y
        }
      })
      s.applyTransform(x, y)
    }
  },

  componentWillUnmount () {
    const s = this

    if (s._dragApplyTimer) {
      clearTimeout(s._dragApplyTimer)
    }
  },

  // ------------------
  // Helper
  // ------------------

  handlePanStart (e) {
    const s = this
    let { center } = e
    s.dragStart(center.x, center.y)
  },

  handlePanMove (e) {
    const s = this
    let { center } = e
    s.dragMove(center.x, center.y)
  },

  handlePanEnd (e) {
    const s = this
    let { center } = e
    s.dragEnd(center.x, center.y)
  },

  handlePanCancel (e) {
    const s = this
    let { center } = e
    s.dragEnd(center.x, center.y)
  },

  dragStart (cx, cy) {
    const s = this
    let { props, state } = s
    if (state.dragging) {
      return
    }
    clearTimeout(s._dragApplyTimer)
    let base = state.move
    let move = veccal.subtract(
      [ cx, cy ],
      [ base.x, base.y ]
    )
    let [x, y] = move
    s.setState({
      dragging: true,
      base: { x, y },
      move: { x: 0, y: 0 }
    })
    if (props.onStart) {
      props.onStart.call(s, s.createEvent(x, y))
    }
  },

  dragMove (cx, cy) {
    const s = this,
      { props, state } = s
    if (!state.dragging) {
      return
    }
    let [x, y] = ApDraggable.movement(cx, cy, state.base, props.direction)
    if (props.shouldMove) {
      let skip = !props.shouldMove({ x, y })
      if (skip) {
        return
      }
    }
    let fromLastTime = new Date() - s._lastDragMoveDate
    let delay = numcal.max(DEFAULT_TRANSITION_DURATION - fromLastTime, 0)
    clearTimeout(s._dragApplyTimer)
    s._dragApplyTimer = setTimeout(() => {
      s.applyTransform(x, y)
      s.setState({
        dragging: true,
        move: { x, y }
      })
      s._lastDragMoveDate = new Date()
    }, delay)

    if (props.onMove) {
      let event = s.createEvent(x, y)
      props.onMove.call(s, event)
    }
  },

  dragEnd (cx, cy) {
    const s = this
    let { props, state } = s
    if (!state.dragging) {
      return
    }
    clearTimeout(s._dragApplyTimer)
    let [x, y] = ApDraggable.movement(cx, cy, state.base, props.direction)
    s.setState({
      dragging: false
    })
    if (props.onStop) {
      props.onStop.call(s, s.createEvent(x, y))
    }
  },

  applyTransform (x, y) {
    const s = this
    let { props } = s
    let {
      minX,
      maxX,
      minY,
      maxY
    } = props
    let elm = ReactDOM.findDOMNode(s)
    x = parseInt(rangecal.round(minX, maxX, x))
    y = parseInt(rangecal.round(minY, maxY, y))
    let transform = `translate(${x}px, ${y}px)`
    let duplicate = s._transform === transform
    if (duplicate) {
      return
    }
    s._transform = transform
    elm.style.transform = transform
  },

  createEvent (x, y) {
    const s = this
    return new CustomEvent('ap:drag', {
      detail: {
        x: x,
        y: y,
        ref: s
      }
    })
  },

  _lastDragMoveDate: new Date(),
  _dragApplyTimer: -1
})

export default ApDraggable

